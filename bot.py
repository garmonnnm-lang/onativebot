import os
import asyncio
import sqlite3
import random
from datetime import datetime, timedelta
import requests
from aiogram import Bot, Dispatcher, types, F
from aiogram.types import Message, InlineKeyboardButton, InlineKeyboardMarkup, CallbackQuery
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode

# ========== –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è ==========
TOKEN = "8250715277:AAHnxkwtZSjelvwHTJy_MBte1fuy_dLqk4o"  # ‚ö†Ô∏è –∑–∞–º–µ–Ω–∏ –Ω–∞ —Å–≤–æ–π
DB = "stats.db"
VIP_PHOTO_URL = "https://avatars.mds.yandex.net/i?id=0a32206d7db896dc1412d53ff74ef5b0_l-5386437-images-thumbs&n=13"
PROMO_CODE = "PENISS"
OWNER_ID = 1909652995  # <-- —Ç–≤–æ–π Telegram ID (–∑–∞–º–µ–Ω–∏ –Ω–∞ —Å–≤–æ–π)
REL_LEVELS = {
    1: {"name": "–°–∏–º–ø–∞—Ç–∏—è üòä", "need": 0},
    2: {"name": "–í–ª—é–±–ª—ë–Ω–Ω–æ—Å—Ç—å üíò", "need": 100},
    3: {"name": "–ü–∞—Ä–∞ üíë", "need": 300},
    4: {"name": "–î—É—à–∏ üíû", "need": 600},
    5: {"name": "–°–µ–º—å—è üíç", "need": 1000},
}
IMPROVE_COST_DIAMONDS = 100
IMPROVE_AFFECTION = 100


# ========== –ë–î –∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ==========
def safe_add_column(cursor, table, column, coltype):
    try:
        cursor.execute(f"ALTER TABLE {table} ADD COLUMN {column} {coltype}")
    except sqlite3.OperationalError:
        pass

def init_db():
    conn = sqlite3.connect(DB)
    c = conn.cursor()

    c.execute('''
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER,
            group_id INTEGER,
            username TEXT,
            total INTEGER DEFAULT 0,
            daily INTEGER DEFAULT 0,
            weekly INTEGER DEFAULT 0,
            monthly INTEGER DEFAULT 0,
            last_msg_date TEXT,
            vip INTEGER DEFAULT 0,
            diamonds INTEGER DEFAULT 0,
            tickets INTEGER DEFAULT 0,
            last_case_time TEXT,
            vip_until TEXT,
            rep INTEGER DEFAULT 0,
            boost_until TEXT,
            PRIMARY KEY(user_id, group_id)
        )
    ''')

    # –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π: –¥–æ–±–∞–≤–ª—è–µ–º –∫–æ–ª–æ–Ω–∫–∏, –µ—Å–ª–∏ —Ç–∞–±–ª–∏—Ü–∞ –±—ã–ª–∞ —Å–æ–∑–¥–∞–Ω–∞ —Å—Ç–∞—Ä–æ–π —Å—Ö–µ–º–æ–π
    safe_add_column(c, "users", "diamonds", "INTEGER DEFAULT 0")
    safe_add_column(c, "users", "tickets", "INTEGER DEFAULT 0")
    safe_add_column(c, "users", "last_case_time", "TEXT")
    safe_add_column(c, "users", "vip_until", "TEXT")
    safe_add_column(c, "users", "rep", "INTEGER DEFAULT 0")
    safe_add_column(c, "users", "boost_until", "TEXT")

    c.execute('''
        CREATE TABLE IF NOT EXISTS marriages (
            group_id INTEGER,
            user1 INTEGER,
            user2 INTEGER,
            status TEXT,
            timestamp TEXT,
            PRIMARY KEY (group_id, user1, user2)
        )
    ''')

    c.execute('''
        CREATE TABLE IF NOT EXISTS relationships (
            group_id INTEGER,
            user1 INTEGER,
            user2 INTEGER,
            level INTEGER DEFAULT 1,
            affection INTEGER DEFAULT 0,
            status TEXT DEFAULT 'pending',
            since TEXT,
            PRIMARY KEY (group_id, user1, user2)
        )
    ''')

    conn.commit()
    conn.close()


# ========== –£—Ç–∏–ª–∏—Ç—ã ==========
def get_username(user: types.User):
    return user.username or (user.full_name if hasattr(user, "full_name") else f"id{user.id}")

def get_username_by_id(user_id: int, group_id: int = None):
    if group_id is None:
        return f"id{user_id}"
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute('SELECT username FROM users WHERE user_id=? AND group_id=?', (user_id, group_id))
    row = c.fetchone()
    conn.close()
    return row[0] if row else f"id{user_id}"

# ========== –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞, VIP, –∞–ª–º–∞–∑—ã ==========
def update_stats(user: types.User, group_id: int):
    user_id = user.id
    username = get_username(user)
    now_date = datetime.utcnow().date()

    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute('SELECT total, daily, weekly, monthly, last_msg_date FROM users WHERE user_id=? AND group_id=?',
              (user_id, group_id))
    row = c.fetchone()

    if not row:
        c.execute(
            "INSERT OR REPLACE INTO users (user_id, group_id, username, total, daily, weekly, monthly, last_msg_date, vip, diamonds, tickets, last_case_time, vip_until) "
            "VALUES (?, ?, ?, 1, 1, 1, 1, ?, 0, 0, 0, NULL, NULL)",
            (user_id, group_id, username, now_date.isoformat())
        )
    else:
        total, daily, weekly, monthly, last_msg = row
        last_msg_date = None
        if last_msg:
            try:
                last_msg_date = datetime.strptime(last_msg, "%Y-%m-%d").date()
            except Exception:
                last_msg_date = None

        new_daily = daily + 1 if last_msg_date == now_date else 1
        last_week = last_msg_date.isocalendar()[1] if last_msg_date else -1
        new_week = weekly + 1 if (last_msg_date and last_week == now_date.isocalendar()[1]
                                  and last_msg_date.year == now_date.year) else 1
        new_month = monthly + 1 if (last_msg_date and (last_msg_date.year, last_msg_date.month) == (now_date.year, now_date.month)) else 1

        c.execute('''
            UPDATE users
            SET username=?, total=total+1, daily=?, weekly=?, monthly=?, last_msg_date=?
            WHERE user_id=? AND group_id=?
        ''', (username, new_daily, new_week, new_month, now_date.isoformat(), user_id, group_id))

    conn.commit()
    conn.close()

def add_diamonds(user_id: int, group_id: int, amount: int):
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute('UPDATE users SET diamonds=COALESCE(diamonds,0)+? WHERE user_id=? AND group_id=?',
              (amount, user_id, group_id))
    conn.commit()
    conn.close()

def get_user_diamonds(user_id: int, group_id: int) -> int:
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("SELECT COALESCE(diamonds,0) FROM users WHERE user_id=? AND group_id=?", (user_id, group_id))
    row = c.fetchone()
    conn.close()
    return row[0] if row else 0

def spend_diamonds(user_id: int, group_id: int, amount: int) -> bool:
    have = get_user_diamonds(user_id, group_id)
    if have < amount:
        return False
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("UPDATE users SET diamonds=diamonds-? WHERE user_id=? AND group_id=?", (amount, user_id, group_id))
    conn.commit()
    conn.close()
    return True

def can_open_case(user_id: int, group_id: int):
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute('SELECT last_case_time FROM users WHERE user_id=? AND group_id=?', (user_id, group_id))
    row = c.fetchone()
    conn.close()
    if not row or not row[0]:
        return True, None
    try:
        last_time = datetime.strptime(row[0], "%Y-%m-%d %H:%M:%S")
    except Exception:
        return True, None
    now = datetime.utcnow()
    if now - last_time >= timedelta(hours=3):
        return True, None
    else:
        left = timedelta(hours=3) - (now - last_time)
        return False, left

def set_case_time(user_id: int, group_id: int):
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute('UPDATE users SET last_case_time=? WHERE user_id=? AND group_id=?',
              (datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S"), user_id, group_id))
    conn.commit()
    conn.close()

def convert_diamonds_to_ticket(user_id: int, group_id: int) -> bool:
    if get_user_diamonds(user_id, group_id) < 300:
        return False
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("UPDATE users SET diamonds=diamonds-300, tickets=COALESCE(tickets,0)+1 WHERE user_id=? AND group_id=?",
              (user_id, group_id))
    conn.commit()
    conn.close()
    return True

def activate_diamond_boost(user_id: int, group_id: int, hours: int = 3):
    until = (datetime.utcnow() + timedelta(hours=hours)).strftime("%Y-%m-%d %H:%M:%S")
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    # –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º –∫–æ–ª–æ–Ω–∫—É
    safe_add_column(c, "users", "boost_until", "TEXT")
    # –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–µ—Ç ‚Äî —Å–æ–∑–¥–∞—ë–º –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é –∑–∞–ø–∏—Å—å
    c.execute("SELECT 1 FROM users WHERE user_id=? AND group_id=?", (user_id, group_id))
    if not c.fetchone():
        c.execute("INSERT OR IGNORE INTO users (user_id, group_id, username) VALUES (?, ?, ?)", (user_id, group_id, f"id{user_id}"))
    c.execute("UPDATE users SET boost_until=? WHERE user_id=? AND group_id=?", (until, user_id, group_id))
    conn.commit()
    conn.close()

def is_diamond_boost_active(user_id: int, group_id: int) -> bool:
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    try:
        c.execute("SELECT boost_until FROM users WHERE user_id=? AND group_id=?", (user_id, group_id))
    except sqlite3.OperationalError:
        conn.close()
        return False
    row = c.fetchone()
    conn.close()
    if not row or not row[0]:
        return False
    try:
        until = datetime.strptime(row[0], "%Y-%m-%d %H:%M:%S")
        return datetime.utcnow() < until
    except Exception:
        return False

def boost_time_left(user_id: int, group_id: int):
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    try:
        c.execute("SELECT boost_until FROM users WHERE user_id=? AND group_id=?", (user_id, group_id))
    except sqlite3.OperationalError:
        conn.close()
        return None
    row = c.fetchone()
    conn.close()
    if not row or not row[0]:
        return None
    try:
        until = datetime.strptime(row[0], "%Y-%m-%d %H:%M:%S")
        left = until - datetime.utcnow()
        return left if left.total_seconds() > 0 else None
    except Exception:
        return None

def give_diamonds(admin_id: int, target_id: int, group_id: int, amount: int):
    if admin_id != OWNER_ID:
        return False, "–¢—ã –Ω–µ –≤–ª–∞–¥–µ–ª–µ—Ü –±–æ—Ç–∞."
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    safe_add_column(c, "users", "diamonds", "INTEGER DEFAULT 0")
    # –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º –∑–∞–ø–∏—Å—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    c.execute("INSERT OR IGNORE INTO users (user_id, group_id, username) VALUES (?, ?, ?)",
              (target_id, group_id, f"id{target_id}"))
    c.execute("UPDATE users SET diamonds = COALESCE(diamonds,0) + ? WHERE user_id=? AND group_id=?",
              (amount, target_id, group_id))
    conn.commit()
    conn.close()
    return True, f"üíé –í—ã–¥–∞–ª {amount} –∞–ª–º–∞–∑(–æ–≤)."

def give_tickets(admin_id: int, target_id: int, group_id: int, amount: int):
    if admin_id != OWNER_ID:
        return False, "–¢—ã –Ω–µ –≤–ª–∞–¥–µ–ª–µ—Ü –±–æ—Ç–∞."
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    safe_add_column(c, "users", "tickets", "INTEGER DEFAULT 0")
    c.execute("INSERT OR IGNORE INTO users (user_id, group_id, username) VALUES (?, ?, ?)",
              (target_id, group_id, f"id{target_id}"))
    c.execute("UPDATE users SET tickets = COALESCE(tickets,0) + ? WHERE user_id=? AND group_id=?",
              (amount, target_id, group_id))
    conn.commit()
    conn.close()
    return True, f"üé´ –í—ã–¥–∞–ª {amount} –±–∏–ª–µ—Ç(–æ–≤)."

def give_vip(admin_id: int, target_id: int, group_id: int, days: int):
    if admin_id != OWNER_ID:
        return False, "–¢—ã –Ω–µ –≤–ª–∞–¥–µ–ª–µ—Ü –±–æ—Ç–∞."
    until = (datetime.utcnow() + timedelta(days=days)).strftime("%Y-%m-%d %H:%M:%S")
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    safe_add_column(c, "users", "vip_until", "TEXT")
    c.execute("INSERT OR IGNORE INTO users (user_id, group_id, username) VALUES (?, ?, ?)",
              (target_id, group_id, f"id{target_id}"))
    c.execute("UPDATE users SET vip = 1, vip_until = ? WHERE user_id = ? AND group_id = ?",
              (until, target_id, group_id))
    conn.commit()
    conn.close()
    return True, f"üåü VIP –≤—ã–¥–∞–Ω –Ω–∞ {days} –¥–Ω–µ–π."

def gift_diamonds(from_id: int, to_id: int, group_id: int, amount: int):
    if amount <= 0:
        return False, "–°—É–º–º–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–π."
    have = get_user_diamonds(from_id, group_id)
    if have < amount:
        return False, "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∞–ª–º–∞–∑–æ–≤."
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    # —É–±–µ–¥–∏–º—Å—è, —á—Ç–æ –∑–∞–ø–∏—Å—å –¥–ª—è to_id –µ—Å—Ç—å
    safe_add_column(c, "users", "diamonds", "INTEGER DEFAULT 0")
    c.execute("INSERT OR IGNORE INTO users (user_id, group_id, username) VALUES (?, ?, ?)",
              (to_id, group_id, f"id{to_id}"))
    # —Å–ø–∏—Å—ã–≤–∞–µ–º
    c.execute("UPDATE users SET diamonds = diamonds - ? WHERE user_id=? AND group_id=?",
              (amount, from_id, group_id))
    # –¥–∞—ë–º
    c.execute("UPDATE users SET diamonds = COALESCE(diamonds,0) + ? WHERE user_id=? AND group_id=?",
              (amount, to_id, group_id))
    conn.commit()
    conn.close()
    return True, f"üéÅ –í—ã –ø–æ–¥–∞—Ä–∏–ª–∏ {amount} –∞–ª–º–∞–∑–æ–≤."

def get_full_stats(group_id: int):
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    # —Å–∫–æ–ª—å–∫–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
    c.execute("SELECT COUNT(*) FROM users WHERE group_id=?", (group_id,))
    total_users = c.fetchone()[0]
    # —Ç–æ–ø –ø–æ —Å–æ–æ–±—â–µ–Ω–∏—è–º (total)
    c.execute("SELECT username, total FROM users WHERE group_id=? ORDER BY total DESC LIMIT 5", (group_id,))
    top_msgs = c.fetchall()
    # —Ç–æ–ø –ø–æ –∞–ª–º–∞–∑–∞–º
    c.execute("SELECT username, diamonds FROM users WHERE group_id=? ORDER BY diamonds DESC LIMIT 5", (group_id,))
    top_diamonds = c.fetchall()
    # —Ç–æ–ø –ø–æ —Ä–µ–ø—É—Ç–∞—Ü–∏–∏
    c.execute("SELECT username, rep FROM users WHERE group_id=? ORDER BY rep DESC LIMIT 5", (group_id,))
    top_rep = c.fetchall()
    # –æ–±—â–∞—è —Å—É–º–º–∞ –∞–ª–º–∞–∑–æ–≤, —Å—Ä–µ–¥–Ω–µ–µ
    c.execute("SELECT SUM(diamonds), AVG(diamonds) FROM users WHERE group_id=?", (group_id,))
    sum_avg = c.fetchone()
    conn.close()
    return {
        "total_users": total_users,
        "top_msgs": top_msgs,
        "top_diamonds": top_diamonds,
        "top_rep": top_rep,
        "sum_diamonds": sum_avg[0] or 0,
        "avg_diamonds": sum_avg[1] or 0.0,
    }






# === –†–µ–ø—É—Ç–∞—Ü–∏—è ===
def safe_add_rep_column():
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    safe_add_column(c, "users", "rep", "INTEGER DEFAULT 0")
    
    conn.commit()
    conn.close()

def change_rep(group_id: int, from_id: int, to_id: int, delta: int):
    if from_id == to_id:
        return "‚ùå –ù–µ–ª—å–∑—è –∏–∑–º–µ–Ω–∏—Ç—å —Ä–µ–ø—É—Ç–∞—Ü–∏—é —Å–∞–º–æ–º—É —Å–µ–±–µ."
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    # —Å–æ–∑–¥–∞—ë–º –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é –∑–∞–ø–∏—Å—å, –µ—Å–ª–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç
    c.execute("INSERT OR IGNORE INTO users (user_id, group_id, username) VALUES (?, ?, ?)",
              (to_id, group_id, f"id{to_id}"))
    c.execute("UPDATE users SET rep=COALESCE(rep,0)+? WHERE user_id=? AND group_id=?", (delta, to_id, group_id))
    conn.commit()
    c.execute("SELECT rep FROM users WHERE user_id=? AND group_id=?", (to_id, group_id))
    new_rep = c.fetchone()[0]
    conn.close()
    if delta > 0:
        return f"üëç –†–µ–ø—É—Ç–∞—Ü–∏—è –ø–æ–≤—ã—à–µ–Ω–∞! –°–µ–π—á–∞—Å: {new_rep}."
    else:
        return f"üëé –†–µ–ø—É—Ç–∞—Ü–∏—è —Å–Ω–∏–∂–µ–Ω–∞. –°–µ–π—á–∞—Å: {new_rep}."



def set_vip_for_3_days(user_id: int, group_id: int):
    until = (datetime.utcnow() + timedelta(days=3)).strftime("%Y-%m-%d %H:%M:%S")
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("UPDATE users SET vip=1, vip_until=? WHERE user_id=? AND group_id=?", (until, user_id, group_id))
    conn.commit()
    conn.close()

def has_activated_promo(user_id: int, group_id: int) -> bool:
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("SELECT vip_until FROM users WHERE user_id=? AND group_id=?", (user_id, group_id))
    row = c.fetchone()
    conn.close()
    if row and row[0]:
        try:
            until = datetime.strptime(row[0], "%Y-%m-%d %H:%M:%S")
            return datetime.utcnow() < until
        except Exception:
            return False
    return False

def is_vip_active(user_id: int, group_id: int) -> bool:
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("SELECT vip, vip_until FROM users WHERE user_id=? AND group_id=?", (user_id, group_id))
    row = c.fetchone()
    conn.close()
    if not row or row[0] != 1:
        return False
    if row[1]:
        try:
            until = datetime.strptime(row[1], "%Y-%m-%d %H:%M:%S")
            if datetime.utcnow() > until:
                conn2 = sqlite3.connect(DB)
                c2 = conn2.cursor()
                c2.execute("UPDATE users SET vip=0 WHERE user_id=? AND group_id=?", (user_id, group_id))
                conn2.commit()
                conn2.close()
                return False
            return True
        except Exception:
            return False
    return True



def get_top(group_id: int, period: str = "total", limit: int = 10):
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    if period not in ["daily", "weekly", "monthly", "total"]:
        period = "total"
    c.execute(f"SELECT username, {period} FROM users WHERE group_id=? ORDER BY {period} DESC LIMIT ?", (group_id, limit))
    rows = c.fetchall()
    conn.close()
    return rows

def format_top(rows):
    text = ""
    for i, (username, count) in enumerate(rows, 1):
        text += f"{i}. {username} ‚Äî {count}\n"
    return text



# ========== –û—Ç–Ω–æ—à–µ–Ω–∏—è ==========
def propose_relationship(group_id: int, proposer_id: int, responder_id: int):
    if proposer_id == responder_id:
        return False, "–ù–µ–ª—å–∑—è –ø—Ä–µ–¥–ª–æ–∂–∏—Ç—å –æ—Ç–Ω–æ—à–µ–Ω–∏—è —Å–∞–º–æ–º—É —Å–µ–±–µ."
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("SELECT * FROM relationships WHERE group_id=? AND status='dating' AND (user1=? OR user2=?)",
              (group_id, proposer_id, proposer_id))
    if c.fetchone():
        conn.close()
        return False, "–£ —Ç–µ–±—è —É–∂–µ –µ—Å—Ç—å –æ—Ç–Ω–æ—à–µ–Ω–∏—è."
    c.execute("SELECT * FROM relationships WHERE group_id=? AND status='dating' AND (user1=? OR user2=?)",
              (group_id, responder_id, responder_id))
    if c.fetchone():
        conn.close()
        return False, "–£ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —É–∂–µ –µ—Å—Ç—å –æ—Ç–Ω–æ—à–µ–Ω–∏—è."
    c.execute("SELECT * FROM relationships WHERE group_id=? AND user1=? AND user2=?", (group_id, proposer_id, responder_id))
    if c.fetchone():
        conn.close()
        return False, "–¢—ã —É–∂–µ —Å–¥–µ–ª–∞–ª –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —ç—Ç–æ–º—É —á–µ–ª–æ–≤–µ–∫—É."
    c.execute("INSERT OR REPLACE INTO relationships (group_id, user1, user2, level, affection, status, since) VALUES (?, ?, ?, 1, 0, 'pending', ?)",
              (group_id, proposer_id, responder_id, datetime.utcnow().isoformat()))
    conn.commit()
    conn.close()
    return True, "OK"

def respond_relationship(group_id: int, proposer_id: int, responder_id: int, accept: bool):
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("SELECT status FROM relationships WHERE group_id=? AND user1=? AND user2=?", (group_id, proposer_id, responder_id))
    row = c.fetchone()
    if not row:
        conn.close()
        return False, "–ù–µ—Ç —Ç–∞–∫–æ–≥–æ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è."
    status = row[0]
    if status != "pending":
        conn.close()
        return False, "–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ."
    if accept:
        c.execute("UPDATE relationships SET status='dating', since=? WHERE group_id=? AND user1=? AND user2=?",
                  (datetime.utcnow().isoformat(), group_id, proposer_id, responder_id))
        msg = "üíû –í—ã —Ç–µ–ø–µ—Ä—å –≤—Å—Ç—Ä–µ—á–∞–µ—Ç–µ—Å—å!"
    else:
        c.execute("DELETE FROM relationships WHERE group_id=? AND user1=? AND user2=?", (group_id, proposer_id, responder_id))
        msg = "‚ùå –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–æ."
    conn.commit()
    conn.close()
    return accept, msg

def get_relationship_info(group_id: int, a_id: int, b_id: int):
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("""
        SELECT user1, user2, level, affection, status, since
        FROM relationships
        WHERE group_id=? AND ((user1=? AND user2=?) OR (user1=? AND user2=?))
    """, (group_id, a_id, b_id, b_id, a_id))
    row = c.fetchone()
    conn.close()
    if not row:
        return None
    u1, u2, lvl, aff, st, sinc = row
    return {"user1": u1, "user2": u2, "level": lvl, "affection": aff, "status": st, "since": sinc}

def improve_relationship(group_id: int, actor_id: int, other_id: int):
    info = get_relationship_info(group_id, actor_id, other_id)
    if not info or info["status"] != "dating":
        return False, "–£ –≤–∞—Å –Ω–µ—Ç –æ—Ç–Ω–æ—à–µ–Ω–∏–π –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è."
    if not spend_diamonds(actor_id, group_id, IMPROVE_COST_DIAMONDS):
        return False, f"–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∞–ª–º–∞–∑–æ–≤. –ù—É–∂–Ω–æ {IMPROVE_COST_DIAMONDS}."
    new_aff = info["affection"] + IMPROVE_AFFECTION
    new_lvl = info["level"]
    while (new_lvl + 1) in REL_LEVELS and new_aff >= REL_LEVELS[new_lvl + 1]["need"]:
        new_lvl += 1
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("""
        UPDATE relationships
        SET affection=?, level=?
        WHERE group_id=? AND ((user1=? AND user2=?) OR (user1=? AND user2=?))
    """, (new_aff, new_lvl, group_id, actor_id, other_id, other_id, actor_id))
    conn.commit()
    conn.close()
    return True, f"–û—Ç–Ω–æ—à–µ–Ω–∏—è —É–ª—É—á—à–µ–Ω—ã: ‚ù§={new_aff}, —É—Ä–æ–≤–µ–Ω—å={new_lvl} ({REL_LEVELS.get(new_lvl, {}).get('name')})"

def break_relationship(group_id: int, user_id: int):
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("DELETE FROM relationships WHERE group_id=? AND (user1=? OR user2=?)", (group_id, user_id, user_id))
    cnt = c.rowcount
    conn.commit()
    conn.close()
    if cnt:
        return True, "–û—Ç–Ω–æ—à–µ–Ω–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω—ã."
    else:
        return False, "–£ —Ç–µ–±—è –Ω–µ—Ç –æ—Ç–Ω–æ—à–µ–Ω–∏–π."

# ========== –ë—Ä–∞–∫ ==========
def propose_marriage(group_id: int, proposer_id: int, responder_id: int):
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("SELECT * FROM marriages WHERE group_id=? AND status='accepted' AND (user1=? OR user2=?)",
              (group_id, proposer_id, proposer_id))
    if c.fetchone():
        conn.close()
        return False, "–£ —Ç–µ–±—è —É–∂–µ –µ—Å—Ç—å –±—Ä–∞–∫!"
    c.execute("SELECT * FROM marriages WHERE group_id=? AND status='accepted' AND (user1=? OR user2=?)",
              (group_id, responder_id, responder_id))
    if c.fetchone():
        conn.close()
        return False, "–£ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —É–∂–µ –µ—Å—Ç—å –±—Ä–∞–∫!"
    c.execute("SELECT * FROM marriages WHERE group_id=? AND status='pending' AND user1=? AND user2=?",
              (group_id, proposer_id, responder_id))
    if c.fetchone():
        conn.close()
        return False, "–¢—ã —É–∂–µ —Å–¥–µ–ª–∞–ª –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —ç—Ç–æ–º—É —á–µ–ª–æ–≤–µ–∫—É."
    c.execute("INSERT INTO marriages (group_id, user1, user2, status, timestamp) VALUES (?, ?, ?, 'pending', ?)",
              (group_id, proposer_id, responder_id, datetime.utcnow().isoformat()))
    conn.commit()
    conn.close()
    return True, "OK"

def respond_marriage(group_id: int, proposer_id: int, responder_id: int, accept: bool):
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("SELECT * FROM marriages WHERE group_id=? AND user1=? AND user2=? AND status='pending'",
              (group_id, proposer_id, responder_id))
    if not c.fetchone():
        conn.close()
        return "–ù–µ—Ç —Ç–∞–∫–æ–≥–æ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è."
    if accept:
        c.execute("UPDATE marriages SET status='accepted' WHERE group_id=? AND user1=? AND user2=?",
                  (group_id, proposer_id, responder_id))
        msg = "üíç –ë—Ä–∞–∫ –∑–∞–∫–ª—é—á—ë–Ω!"
    else:
        c.execute("DELETE FROM marriages WHERE group_id=? AND user1=? AND user2=?",
                  (group_id, proposer_id, responder_id))
        msg = "‚ùå –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–æ."
    conn.commit()
    conn.close()
    return msg

def get_my_marriage(group_id: int, user_id: int) -> str:
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("SELECT user1, user2 FROM marriages WHERE group_id=? AND status='accepted' AND (user1=? OR user2=?)",
              (group_id, user_id, user_id))
    row = c.fetchone()
    conn.close()
    if row:
        other = row[1] if row[0] == user_id else row[0]
        return f"üíç –¢—ã –≤ –±—Ä–∞–∫–µ —Å <a href='tg://user?id={other}'>–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º</a>"
    conn2 = sqlite3.connect(DB)
    c2 = conn2.cursor()
    c2.execute("SELECT user1 FROM marriages WHERE group_id=? AND user2=? AND status='pending'", (group_id, user_id))
    row2 = c2.fetchone()
    conn2.close()
    if row2:
        return "üíå –£ —Ç–µ–±—è –µ—Å—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –≤ –æ–∂–∏–¥–∞–Ω–∏–∏."
    return "–£ —Ç–µ–±—è –Ω–µ—Ç –±—Ä–∞–∫–∞."

def divorce(group_id: int, user_id: int) -> str:
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("DELETE FROM marriages WHERE group_id=? AND status='accepted' AND (user1=? OR user2=?)",
              (group_id, user_id, user_id))
    conn.commit()
    conn.close()
    return "‚ùå –ë—Ä–∞–∫ —Ä–∞—Å—Ç–æ—Ä–≥–Ω—É—Ç."

# ========== –ë–æ—Ç –∏ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ ==========
bot = Bot(token=TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher()

@dp.message()
async def handle_all(message: Message):
    if not message.chat or not message.chat.type or not message.chat.type.endswith("group"):
        return
    if not message.text:
        return

    text = message.text.strip()
    tl = text.lower()
    group_id = message.chat.id
    user = message.from_user

    try:
        update_stats(user, group_id)
    except Exception as e:
        print("update_stats error:", e)

    # ‚Äî –∫–µ–π—Å—ã ‚Äî
    if tl.startswith("–∫–µ–π—Å"):
        can, left = can_open_case(user.id, group_id)
        if not can and left:
            sec = int(left.total_seconds())
            h, rem = divmod(sec, 3600)
            m, s = divmod(rem, 60)
            await message.reply(f"‚è≥ –£–∂–µ –æ—Ç–∫—Ä—ã–≤–∞–ª! –ñ–¥–∞—Ç—å: <b>{h}—á {m}–º {s}—Å</b>")
        else:
            amt = random.randint(5, 35)
            if is_diamond_boost_active(user.id, group_id):
                amt *= 2
            add_diamonds(user.id, group_id, amt)
            set_case_time(user.id, group_id)
            await message.reply(f"üéÅ –¢—ã –æ—Ç–∫—Ä—ã–ª –∫–µ–π—Å –∏ –ø–æ–ª—É—á–∏–ª <b>{amt} –∞–ª–º–∞–∑–æ–≤</b>!")
        return

    # ‚Äî –æ–±–º–µ–Ω ‚Äî
    if tl.startswith("–±–∏–ª–µ—Ç") or tl.startswith("–æ–±–º–µ–Ω"):
        if convert_diamonds_to_ticket(user.id, group_id):
            await message.reply("üé´ –¢—ã –æ–±–º–µ–Ω—è–ª 300 –∞–ª–º–∞–∑–æ–≤ –Ω–∞ 1 –±–∏–ª–µ—Ç.")
        else:
            await message.reply("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∞–ª–º–∞–∑–æ–≤ (–Ω—É–∂–Ω–æ 300).")
        return

    # ‚Äî –ø—Ä–æ–º–æ–∫–æ–¥ ‚Äî
    if tl.startswith("–ø—Ä–æ–º–∏–∫"):
        parts = message.text.split()
        if len(parts) == 2 and parts[1].upper() == PROMO_CODE:
            if has_activated_promo(user.id, group_id):
                await message.reply("‚ùóÔ∏è–¢—ã —É–∂–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–ª –ø—Ä–æ–º–æ–∫–æ–¥ –∏–ª–∏ VIP —É–∂–µ –¥–µ–π—Å—Ç–≤—É–µ—Ç.")
            else:
                set_vip_for_3_days(user.id, group_id)
                await message.reply("üéâ –ü—Ä–æ–º–æ–∫–æ–¥ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω! VIP –Ω–∞ 3 –¥–Ω—è.")
        else:
            await message.reply("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –ø—Ä–æ–º–æ–∫–æ–¥.")
        return

        # ‚Äî –ø–æ–º–æ—â—å ‚Äî
    if tl.startswith("–ø–æ–º–æ—â") or tl == "help":
        help_text = (
            "üí° <b>–ö–æ–º–∞–Ω–¥—ã –±–æ—Ç–∞:</b>\n\n"
            "üìà <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</b>\n"
            "‚Ä¢ —Å—Ç–∞—Ç–∞ [–¥–µ–Ω—å/–Ω–µ–¥–µ–ª—è/–º–µ—Å—è—Ü/–≤—Å–µ] ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π\n"
            "‚Ä¢ —Ç–æ–ø [–¥–µ–Ω—å/–Ω–µ–¥–µ–ª—è/–º–µ—Å—è—Ü/–≤—Å–µ] ‚Äî —Ç–æ–ø –ø–æ —Å–æ–æ–±—â–µ–Ω–∏—è–º\n\n"
            "üíé <b>–≠–∫–æ–Ω–æ–º–∏–∫–∞</b>\n"
            "‚Ä¢ –∫–µ–π—Å ‚Äî –æ—Ç–∫—Ä—ã—Ç—å –∫–µ–π—Å (—Ä–∞–∑ –≤ 3 —á–∞—Å–∞)\n"
            "‚Ä¢ –±–∏–ª–µ—Ç / –æ–±–º–µ–Ω ‚Äî –æ–±–º–µ–Ω—è—Ç—å 300 –∞–ª–º–∞–∑–æ–≤ –Ω–∞ –±–∏–ª–µ—Ç\n"
            "‚ù§Ô∏è <b>–û—Ç–Ω–æ—à–µ–Ω–∏—è</b>\n"
            "‚Ä¢ –ø—Ä–µ–¥–ª–æ–∂–∏—Ç—å [@–Ω–∏–∫ –∏–ª–∏ –æ—Ç–≤–µ—Ç–æ–º] ‚Äî –ø—Ä–µ–¥–ª–æ–∂–∏—Ç—å –æ—Ç–Ω–æ—à–µ–Ω–∏—è\n"
            "‚Ä¢ –æ—Ç–Ω–æ—à–µ–Ω–∏—è [@–Ω–∏–∫] ‚Äî –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –æ—Ç–Ω–æ—à–µ–Ω–∏—è\n"
            "‚Ä¢ —É–ª—É—á—à–∏—Ç—å (–æ—Ç–≤–µ—Ç–æ–º) ‚Äî –ø–æ–≤—ã—Å–∏—Ç—å —É—Ä–æ–≤–µ–Ω—å –∑–∞ 100 –∞–ª–º–∞–∑–æ–≤\n"
            "‚Ä¢ —Ä–∞—Å—Å—Ç–∞—Ç—å—Å—è ‚Äî –∑–∞–∫–æ–Ω—á–∏—Ç—å –æ—Ç–Ω–æ—à–µ–Ω–∏—è\n\n"
            "üíç <b>–ë—Ä–∞–∫</b>\n"
            "‚Ä¢ –±—Ä–∞–∫ [@–Ω–∏–∫ –∏–ª–∏ –æ—Ç–≤–µ—Ç–æ–º] ‚Äî –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —Ä—É–∫–∏ –∏ —Å–µ—Ä–¥—Ü–∞\n"
            "‚Ä¢ –ø—Ä–∏–Ω—è—Ç—å / –æ—Ç–∫–ª–æ–Ω–∏—Ç—å (–æ—Ç–≤–µ—Ç–æ–º) ‚Äî –æ—Ç–≤–µ—Ç –Ω–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ\n"
            "‚Ä¢ —Ä–∞–∑–≤–æ–¥ ‚Äî —Ä–∞—Å—Ç–æ—Ä–≥–Ω—É—Ç—å –±—Ä–∞–∫\n"
            "‚Ä¢ –±—Ä–∞–∫ ‚Äî –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Ç–µ–∫—É—â–∏–π –±—Ä–∞–∫\n\n"
            "‚≠êÔ∏è <b>–ü—Ä–æ—Ñ–∏–ª—å</b>\n"
            "‚Ä¢ –ø—Ä–æ—Ñ–∏–ª—å ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å —Å–≤–æ—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∏ –¥–∞–Ω–Ω—ã–µ\n"
            "‚Ä¢ —Ä–µ–ø [@–Ω–∏–∫ –∏–ª–∏ –æ—Ç–≤–µ—Ç–æ–º] + / - ‚Äî –∏–∑–º–µ–Ω–∏—Ç—å —Ä–µ–ø—É—Ç–∞—Ü–∏—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n\n"
            "üìö <b>–ü—Ä–æ—á–µ–µ</b>\n"
            "‚Ä¢ –ø–æ–º–æ—â—å ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ"
        )
        await message.reply(help_text)
        return



    # ‚Äî –∞–ª–º–∞–∑–Ω—ã–π –±—É—Å—Ç ‚Äî
    if tl.startswith("–±—É—Å—Ç"):
        if is_diamond_boost_active(user.id, group_id):
            left = boost_time_left(user.id, group_id)
            if left:
                h, m = divmod(int(left.total_seconds()) // 60, 60)
                await message.reply(f"‚ö° –ê–ª–º–∞–∑–Ω—ã–π –±—É—Å—Ç —É–∂–µ –∞–∫—Ç–∏–≤–µ–Ω! –û—Å—Ç–∞–ª–æ—Å—å {h}—á {m}–º.")
            return
        if not spend_diamonds(user.id, group_id, 500):
            await message.reply("‚ùå –ù—É–∂–Ω–æ 500 –∞–ª–º–∞–∑–æ–≤ –¥–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –±—É—Å—Ç–∞.")
            return
        activate_diamond_boost(user.id, group_id)
        await message.reply("üíé –ê–ª–º–∞–∑–Ω—ã–π –±—É—Å—Ç –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω –Ω–∞ 3 —á–∞—Å–∞! –í—Å–µ –Ω–∞–≥—Ä–∞–¥—ã –∏–∑ –∫–µ–π—Å–æ–≤ x2.")
        return
    
    # ‚Äî –ø—Ä–æ—Ñ–∏–ª—å ‚Äî
    if tl.startswith("–ø—Ä–æ—Ñ–∏–ª—å"):
        txt, vip = get_user_profile(user.id, group_id)
        if vip:
            await message.answer_photo(VIP_PHOTO_URL, caption=txt)
        else:
            await message.reply(txt)
        return

    # ‚Äî –æ—Ç–Ω–æ—à–µ–Ω–∏—è: –ø—Ä–µ–¥–ª–æ–∂–∏—Ç—å ‚Äî
    if tl.startswith("–ø—Ä–µ–¥–ª–æ–∂–∏—Ç—å"):
        partner_id = None
        if message.reply_to_message:
            partner_id = message.reply_to_message.from_user.id
        else:
            parts = text.split()
            if len(parts) >= 2:
                nick = parts[1].lstrip("@")
                partner_id = find_user_id_by_nick(group_id, nick)
        if not partner_id:
            await message.reply("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è. –û—Ç–≤–µ—Ç—å –∏–ª–∏ —É–∫–∞–∂–∏ –Ω–∏–∫: `–ø—Ä–µ–¥–ª–æ–∂–∏—Ç—å @–Ω–∏–∫`.")
            return
        if partner_id == user.id:
            await message.reply("–ù–µ–ª—å–∑—è –ø—Ä–µ–¥–ª–æ–∂–∏—Ç—å –æ—Ç–Ω–æ—à–µ–Ω–∏—è —Å–∞–º–æ–º—É —Å–µ–±–µ.")
            return
        ok, msg = propose_relationship(group_id, user.id, partner_id)
        if not ok:
            await message.reply(msg)
        else:
            proposer = get_username(user)
            partner_name = get_username_by_id(partner_id, group_id)
            kb = InlineKeyboardMarkup(inline_keyboard=[
                [
                    InlineKeyboardButton(
                        text="üíû –ü—Ä–∏–Ω—è—Ç—å",
                        callback_data=f"rel_accept:{user.id}:{partner_id}:{group_id}"
                    ),
                    InlineKeyboardButton(
                        text="‚ùå –û—Ç–∫–ª–æ–Ω–∏—Ç—å",
                        callback_data=f"rel_decline:{user.id}:{partner_id}:{group_id}"
                    )
                ]
            ])
            await message.answer(f"üíå <b>{proposer}</b> –ø—Ä–µ–¥–ª–∞–≥–∞–µ—Ç –æ—Ç–Ω–æ—à–µ–Ω–∏—è <b>{partner_name}</b>!", reply_markup=kb)
        return



    # ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å –æ—Ç–Ω–æ—à–µ–Ω–∏—è ‚Äî
    if tl.startswith("–æ—Ç–Ω–æ—à–µ–Ω–∏—è"):
        target = None
        if message.reply_to_message:
            target = message.reply_to_message.from_user.id
        else:
            parts = text.split()
            if len(parts) >= 2:
                nick = parts[1]
                conn = sqlite3.connect(DB)
                c = conn.cursor()
                c.execute('SELECT user_id FROM users WHERE group_id=? AND username LIKE ?', (group_id, f"%{nick}%"))
                row = c.fetchone()
                conn.close()
                if row:
                    target = row[0]
        if not target:
            await message.reply("–û—Ç–≤–µ—Ç—å –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.")
            return
        info = get_relationship_info(group_id, user.id, target)
        if not info:
            await message.reply("–£ –≤–∞—Å –Ω–µ—Ç –æ—Ç–Ω–æ—à–µ–Ω–∏–π.")
        else:
            lvl = info["level"]
            aff = info["affection"]
            st = info["status"]
            sinc = info["since"] or "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
            pid = info["user2"] if info["user1"] == user.id else info["user1"]
            pname = get_username_by_id(pid, group_id)
            lvl_name = REL_LEVELS.get(lvl, {}).get("name", f"–£—Ä–æ–≤–µ–Ω—å {lvl}")
            await message.reply(
                f"üíû –û—Ç–Ω–æ—à–µ–Ω–∏—è —Å {pname}\n"
                f"–°—Ç–∞—Ç—É—Å: <b>{st}</b>\n"
                f"–£—Ä–æ–≤–µ–Ω—å: <b>{lvl_name}</b> ({lvl})\n"
                f"–û—á–∫–∏ —Å–∏–º–ø–∞—Ç–∏–∏: <b>{aff}</b>\n"
                f"–°: <b>{sinc}</b>"
            )
        return

    # ‚Äî —É–ª—É—á—à–∏—Ç—å –æ—Ç–Ω–æ—à–µ–Ω–∏—è ‚Äî
    if tl.startswith("—É–ª—É—á—à–∏—Ç—å"):
        if not message.reply_to_message:
            await message.reply("–û—Ç–≤–µ—Ç—å –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–∞—Ä—Ç–Ω—ë—Ä–∞ –∫–æ–º–∞–Ω–¥–æ–π `—É–ª—É—á—à–∏—Ç—å`.")
            return
        partner_id = message.reply_to_message.from_user.id
        ok, msg = improve_relationship(group_id, user.id, partner_id)
        await message.reply(msg)
        return
    
    # === –ö–æ–º–∞–Ω–¥–∞ –≤–ª–∞–¥–µ–ª—å—Ü–∞ "–≤—ã–¥–∞—Ç—å ..." ===
    OWNER_ID = 1909652995  # üëà –∑–∞–º–µ–Ω–∏ –Ω–∞ —Å–≤–æ–π ID, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ

    if user.id == OWNER_ID and tl.startswith("–≤—ã–¥–∞—Ç—å"):
        parts = text.split()
        if len(parts) < 3:
            await message.reply("‚öôÔ∏è –§–æ—Ä–º–∞—Ç: –≤—ã–¥–∞—Ç—å [–∞–ª–º–∞–∑—ã/–≤–∏–ø/–±–∏–ª–µ—Ç—ã] [—á–∏—Å–ª–æ] [@–Ω–∏–∫ –∏–ª–∏ –æ—Ç–≤–µ—Ç–æ–º]")
            return

        what = parts[1].lower()
        try:
            amount = int(parts[2])
        except ValueError:
            await message.reply("‚ùó –ö–æ–ª-–≤–æ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å —á–∏—Å–ª–æ–º.")
            return

        # –æ–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–æ–º—É –≤—ã–¥–∞–≤–∞—Ç—å
        target_id = None
        if message.reply_to_message:
            target_id = message.reply_to_message.from_user.id
            target_name = get_username(message.reply_to_message.from_user)
        elif len(parts) >= 4 and parts[3].startswith("@"):
            nick = parts[3].lstrip("@")
            target_id = find_user_id_by_nick(group_id, nick)
            target_name = nick
        else:
            await message.reply("‚öôÔ∏è –£–∫–∞–∂–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —á–µ—Ä–µ–∑ @ –∏–ª–∏ –æ—Ç–≤–µ—Ç–æ–º.")
            return

        if not target_id:
    # –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω ‚Äî —Å–æ–∑–¥–∞—ë–º –∑–∞–ø–∏—Å—å –≤—Ä—É—á–Ω—É—é
            target_name = nick
            conn = sqlite3.connect(DB)
            c = conn.cursor()
            c.execute("INSERT OR IGNORE INTO users (user_id, group_id, username) VALUES (?, ?, ?)",
                      (random.randint(100000000, 999999999), group_id, target_name))
            conn.commit()
            conn.close()
            await message.reply(f"‚ö†Ô∏è –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {target_name} –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –ë–î, –¥–æ–±–∞–≤–ª–µ–Ω –≤—Ä—É—á–Ω—É—é.")
            return

        conn = sqlite3.connect(DB)
        c = conn.cursor()

        # –≤—ã–¥–∞—á–∞ –ø–æ —Ç–∏–ø—É
        if what in ["–∞–ª–º–∞–∑—ã", "–∞–ª–º–∞–∑", "diamond", "diamonds"]:
            c.execute("UPDATE users SET diamonds = COALESCE(diamonds,0) + ? WHERE user_id=? AND group_id=?", (amount, target_id, group_id))
            res_icon = "üíé"
            msg = f"‚úÖ –í—ã–¥–∞–Ω–æ {amount} {res_icon} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é <b>{target_name}</b>."
        elif what in ["–±–∏–ª–µ—Ç—ã", "–±–∏–ª–µ—Ç", "ticket", "tickets"]:
            c.execute("UPDATE users SET tickets = COALESCE(tickets,0) + ? WHERE user_id=? AND group_id=?", (amount, target_id, group_id))
            res_icon = "üé´"
            msg = f"‚úÖ –í—ã–¥–∞–Ω–æ {amount} {res_icon} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é <b>{target_name}</b>."
        elif what in ["–≤–∏–ø", "vip"]:
            # VIP –≤—ã–¥–∞—ë—Ç—Å—è –≤ –¥–Ω—è—Ö
            until = (datetime.utcnow() + timedelta(days=amount)).strftime("%Y-%m-%d %H:%M:%S")
            c.execute("UPDATE users SET vip=1, vip_until=? WHERE user_id=? AND group_id=?", (until, target_id, group_id))
            res_icon = "üåü"
            msg = f"‚úÖ –í—ã–¥–∞–Ω VIP {res_icon} –Ω–∞ {amount} –¥–Ω. –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é <b>{target_name}</b>."
        else:
            conn.close()
            await message.reply("‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø. –ò—Å–ø–æ–ª—å–∑—É–π: –∞–ª–º–∞–∑—ã, –±–∏–ª–µ—Ç—ã, –≤–∏–ø.")
            return

        conn.commit()
        conn.close()

        await message.reply(msg)
        return



    # ‚Äî —Ç–æ–ø –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π ‚Äî
    if tl.startswith("—Ç–æ–ø"):
        parts = tl.split()
        period = parts[1] if len(parts) > 1 else "–≤—Å–µ"
        period_map = {"–¥–µ–Ω—å": "daily", "–Ω–µ–¥–µ–ª—è": "weekly", "–º–µ—Å—è—Ü": "monthly", "–≤—Å–µ": "total"}
        top_period = period_map.get(period, "total")
        top_users = get_top(group_id, top_period)
        if not top_users:
            await message.reply("–ü–æ–∫–∞ –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Ç–æ–ø–∞.")
        else:
            txt = f"üèÜ –¢–æ–ø {period}:\n" + format_top(top_users)
            await message.reply(txt)
        return

    # ‚Äî –ø–æ–¥–∞—Ä–∏—Ç—å ‚Äî –∫–æ–º–∞–Ω–¥–∞ "–ø–æ–¥–∞—Ä–∏—Ç—å @–Ω–∏–∫ 100" –∏–ª–∏ "–ø–æ–¥–∞—Ä–∏—Ç—å 100" –æ—Ç–≤–µ—Ç–æ–º
    if tl.startswith("–ø–æ–¥–∞—Ä–∏—Ç—å"):
        parts = text.split()
        target_id = None
        amount = None
        if message.reply_to_message:
            target_id = message.reply_to_message.from_user.id
            if len(parts) >= 2:
                try:
                    amount = int(parts[1])
                except:
                    pass
        else:
            if len(parts) >= 3:
                # parts[1] ‚Äî –Ω–∏–∫, parts[2] ‚Äî —Å—É–º–º–∞
                nick = parts[1].lstrip("@")
                try:
                    amount = int(parts[2])
                except:
                    amount = None
                target_id = find_user_id_by_nick(group_id, nick)
        if not target_id or amount is None:
            await message.reply("–ò—Å–ø–æ–ª—å–∑—É–π: `–ø–æ–¥–∞—Ä–∏—Ç—å @–Ω–∏–∫ <—á–∏—Å–ª–æ>` –∏–ª–∏ –æ—Ç–≤–µ—Ç–∏–≤ –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ: `–ø–æ–¥–∞—Ä–∏—Ç—å <—á–∏—Å–ª–æ>`")
            return
        ok, msg = gift_diamonds(user.id, target_id, group_id, amount)
        await message.reply(msg)
        return

    if tl.startswith("–≤—Å—è—Å—Ç–∞—Ç") or tl.startswith("/–≤—Å—è—Å—Ç–∞—Ç"):
        st = get_full_stats(group_id)
        txt = (
            f"üìä –í—Å–µ—Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –≥—Ä—É–ø–ø—ã\n\n"
            f"üë• –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {st['total_users']}\n"
            f"üíé –í—Å–µ–≥–æ –∞–ª–º–∞–∑–æ–≤ —É —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤: {st['sum_diamonds']}\n"
            f"üí† –°—Ä–µ–¥–Ω–µ–µ –∞–ª–º–∞–∑–æ–≤: {st['avg_diamonds']:.2f}\n\n"
            "üèÜ –¢–æ–ø –ø–æ —Å–æ–æ–±—â–µ–Ω–∏—è–º:\n"
        )
        for i, (name, cnt) in enumerate(st["top_msgs"], 1):
            txt += f"{i}. {name} ‚Äî {cnt}\n"
        txt += "\nüíé –¢–æ–ø –ø–æ –∞–ª–º–∞–∑–∞–º:\n"
        for i, (name, cnt) in enumerate(st["top_diamonds"], 1):
            txt += f"{i}. {name} ‚Äî {cnt}\n"
        txt += "\nüìù –¢–æ–ø –ø–æ —Ä–µ–ø—É—Ç–∞—Ü–∏–∏:\n"
        for i, (name, cnt) in enumerate(st["top_rep"], 1):
            txt += f"{i}. {name} ‚Äî {cnt}\n"
        await message.reply(txt)
        return


    # ‚Äî —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π ‚Äî
    if tl.startswith("—Å—Ç–∞—Ç–∞"):
        parts = tl.split()
        period = parts[1] if len(parts) > 1 else "–¥–µ–Ω—å"
        period_map = {"–¥–µ–Ω—å": "daily", "–Ω–µ–¥–µ–ª—è": "weekly", "–º–µ—Å—è—Ü": "monthly", "–≤—Å–µ": "total"}
        stat_period = period_map.get(period, "daily")
        conn = sqlite3.connect(DB)
        c = conn.cursor()
        c.execute(f"SELECT username, {stat_period} FROM users WHERE group_id=? ORDER BY {stat_period} DESC LIMIT 10", (group_id,))
        rows = c.fetchall()
        conn.close()
        if not rows:
            await message.reply("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏.")
        else:
            txt = f"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ {period}:\n" + format_top(rows)
            await message.reply(txt)
        return

    # ‚Äî —Ä–∞—Å—Å—Ç–∞—Ç—å—Å—è ‚Äî
    if tl.startswith("—Ä–∞—Å—Å—Ç–∞—Ç—å—Å—è"):
        ok, msg = break_relationship(group_id, user.id)
        await message.reply(msg)
        return

    # ‚Äî –±—Ä–∞–∫ ‚Äî
    if tl.startswith("–±—Ä–∞–∫"):
        parts = text.split()
        partner_id = None
        if len(parts) == 1 and not message.reply_to_message:
            await message.reply(get_my_marriage(group_id, user.id))
            return
        if message.reply_to_message:
            partner_id = message.reply_to_message.from_user.id
        elif len(parts) >= 2:
            partner_id = find_user_id_by_nick(group_id, parts[1])
        if not partner_id:
            await message.reply("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
            return
        if partner_id == user.id:
            await message.reply("–ù–µ–ª—å–∑—è –∂–µ–Ω–∏—Ç—å—Å—è –Ω–∞ —Å–µ–±–µ :)")
            return
        ok, msg = propose_marriage(group_id, user.id, partner_id)
        if not ok:
            await message.reply(msg)
        else:
            proposer = get_username(user)
            pname = get_username_by_id(partner_id, group_id)
            kb = InlineKeyboardMarkup(inline_keyboard=[
                [
                    InlineKeyboardButton(
                        text="üíç –ü—Ä–∏–Ω—è—Ç—å",
                        callback_data=f"marriage_accept:{user.id}:{partner_id}:{group_id}"
                    ),
                    InlineKeyboardButton(
                        text="‚ùå –û—Ç–∫–ª–æ–Ω–∏—Ç—å",
                        callback_data=f"marriage_decline:{user.id}:{partner_id}:{group_id}"
                    )
                ]
            ])
            await message.answer(f"üíå <b>{proposer}</b> –ø—Ä–µ–¥–ª–∞–≥–∞–µ—Ç –±—Ä–∞–∫ <b>{pname}</b>!", reply_markup=kb)
        return
    


    # --- –ü–†–û–®–ï–ü–¢–ê–¢–¨ ---
    if tl.startswith("–ø—Ä–æ—à–µ–ø—Ç–∞—Ç—å"):
        import uuid, time, asyncio
        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery

        # –≥–ª–æ–±–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º–µ–Ω–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ —Å–µ–∫—Ä–µ—Ç–æ–≤
        global whispers, whispers_lock
        if "whispers" not in globals():
            whispers = {}
            whispers_lock = asyncio.Lock()
        WHISPER_TTL = 60 * 60 * 24  # —Å—É—Ç–∫–∏

        parts = text.split(maxsplit=2)
        recipient_id = None
        whisper_text = None

        # –í–∞—Ä–∏–∞–Ω—Ç 1: –æ—Ç–≤–µ—Ç–æ–º –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ
        if message.reply_to_message:
            recipient_id = message.reply_to_message.from_user.id
            whisper_text = text[len("–ø—Ä–æ—à–µ–ø—Ç–∞—Ç—å"):].strip()
            if not whisper_text:
                await message.reply("–ù–∞–ø–∏—à–∏ —Ç–µ–∫—Å—Ç –ø—Ä–æ—à–µ–ø—Ç–∞–Ω–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è.")
                return

        # –í–∞—Ä–∏–∞–Ω—Ç 2: –Ω–∏–∫ –∏ —Ç–µ–∫—Å—Ç –≤ –æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–µ
        elif len(parts) >= 3:
            nick = parts[1].lstrip("@")
            recipient_id = find_user_id_by_nick(group_id, nick)
            whisper_text = parts[2].strip()

        else:
            await message.reply("–ò—Å–ø–æ–ª—å–∑—É–π: `–ø—Ä–æ—à–µ–ø—Ç–∞—Ç—å @–Ω–∏–∫ —Ç–µ–∫—Å—Ç` –∏–ª–∏ –æ—Ç–≤–µ—Ç–æ–º –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ: `–ø—Ä–æ—à–µ–ø—Ç–∞—Ç—å —Ç–µ–∫—Å—Ç`")
            return

        if not recipient_id:
            await message.reply("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.")
            return
        if recipient_id == user.id:
            await message.reply("–ù–µ–ª—å–∑—è –ø—Ä–æ—à–µ–ø—Ç–∞—Ç—å —Å–∞–º–æ–º—É —Å–µ–±–µ.")
            return

        # —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
        token = uuid.uuid4().hex
        async with whispers_lock:
            whispers[token] = {
                "text": whisper_text,
                "from": user.id,
                "to": recipient_id,
                "created": time.time()
            }

        sender_name = get_username(user)
        rec_name = get_username_by_id(recipient_id, group_id)
        kb = InlineKeyboardMarkup(inline_keyboard=[[
            InlineKeyboardButton(
                text="üîí –û—Ç–∫—Ä—ã—Ç—å –ø—Ä–æ—à–µ–ø—Ç–∞–Ω–Ω–æ–µ",
                callback_data=f"whisper_open:{token}:{recipient_id}:{user.id}"
            )
        ]])
        await message.reply(
            f"üí¨ <b>{sender_name}</b> –ø—Ä–æ—à–µ–ø—Ç–∞–ª(–∞) <b>{rec_name}</b>.",
            reply_markup=kb
        )
        return



    # ‚Äî —Ä–µ–ø—É—Ç–∞—Ü–∏—è ‚Äî
    if tl.startswith("+—Ä–µ–ø"):
        target_id = None
        if message.reply_to_message:
            target_id = message.reply_to_message.from_user.id
        else:
            parts = text.split()
            if len(parts) >= 2:
                target_id = find_user_id_by_nick(group_id, parts[1].lstrip("@"))
        if not target_id:
            await message.reply("–£–∫–∞–∂–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ‚Äî –æ—Ç–≤–µ—Ç–æ–º –∏–ª–∏ –Ω–∏–∫–æ–º: +—Ä–µ–ø @–Ω–∏–∫")
            return
        msg = change_rep(group_id, user.id, target_id, +1)
        await message.reply(msg)
        return

    if tl.startswith("-—Ä–µ–ø"):
        target_id = None
        if message.reply_to_message:
            target_id = message.reply_to_message.from_user.id
        else:
            parts = text.split()
            if len(parts) >= 2:
                target_id = find_user_id_by_nick(group_id, parts[1].lstrip("@"))
        if not target_id:
            await message.reply("–£–∫–∞–∂–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ‚Äî –æ—Ç–≤–µ—Ç–æ–º –∏–ª–∏ –Ω–∏–∫–æ–º: -—Ä–µ–ø @–Ω–∏–∫")
            return
        msg = change_rep(group_id, user.id, target_id, -1)
        await message.reply(msg)
        return


    if tl.startswith("–ø—Ä–∏–Ω—è—Ç—å") and message.reply_to_message:
        pid = message.reply_to_message.from_user.id
        rid = user.id
        await message.reply(respond_marriage(group_id, pid, rid, accept=True))
        return
    if tl.startswith("–æ—Ç–∫–ª–æ–Ω–∏—Ç—å") and message.reply_to_message:
        pid = message.reply_to_message.from_user.id
        rid = user.id
        await message.reply(respond_marriage(group_id, pid, rid, accept=False))
        return
    if tl.startswith("—Ä–∞–∑–≤–æ–¥"):
        await message.reply(divorce(group_id, user.id))
        return

@dp.callback_query(F.data.startswith("rel_accept"))
async def cb_rel_accept(callback: CallbackQuery):
    _, pid, rid, gid = callback.data.split(":")
    pid, rid, gid = int(pid), int(rid), int(gid)
    if callback.from_user.id != rid:
        await callback.answer("–≠—Ç–æ –Ω–µ –¥–ª—è —Ç–µ–±—è!", show_alert=True)
        return
    ok, msg = respond_relationship(gid, pid, rid, accept=True)
    if ok:
        pname = get_username_by_id(pid, gid)
        rname = get_username(callback.from_user)
        await callback.message.edit_text(f"üéâ <b>{rname}</b> –∏ <b>{pname}</b> —Ç–µ–ø–µ—Ä—å –≤—Å—Ç—Ä–µ—á–∞—é—Ç—Å—è! ‚ù§Ô∏è")
    else:
        await callback.message.edit_text(msg)
    await callback.answer(msg)
@dp.callback_query(F.data.startswith("whisper_open"))
async def cb_whisper_open(callback: CallbackQuery):
    import time
    try:
        _, token, rid, sid = callback.data.split(":")
        rid, sid = int(rid), int(sid)
    except:
        await callback.answer("–û—à–∏–±–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞.", show_alert=True)
        return

    if callback.from_user.id != rid:
        await callback.answer("–≠—Ç–æ –Ω–µ –¥–ª—è —Ç–µ–±—è!", show_alert=True)
        return

    async with whispers_lock:
        data = whispers.get(token)
        if not data:
            await callback.answer("–ü—Ä–æ—à–µ–ø—Ç–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –∏–ª–∏ —É–∂–µ –æ—Ç–∫—Ä—ã—Ç–æ.", show_alert=True)
            return
        if data["to"] != rid:
            await callback.answer("–≠—Ç–æ –Ω–µ –¥–ª—è —Ç–µ–±—è!", show_alert=True)
            return
        text = data["text"]
        del whispers[token]

    await callback.answer(text, show_alert=True)
    try:
        await callback.message.edit_text(callback.message.text + "\n\nüîì –ü—Ä–æ—à–µ–ø—Ç–∞–Ω–Ω–æ–µ –æ—Ç–∫—Ä—ã—Ç–æ.")
    except:
        pass

@dp.callback_query(F.data.startswith("rel_decline"))
async def cb_rel_decline(callback: CallbackQuery):
    _, pid, rid, gid = callback.data.split(":")
    pid, rid, gid = int(pid), int(rid), int(gid)
    if callback.from_user.id != rid:
        await callback.answer("–≠—Ç–æ –Ω–µ –¥–ª—è —Ç–µ–±—è!", show_alert=True)
        return
    ok, msg = respond_relationship(gid, pid, rid, accept=False)
    await callback.message.edit_text("‚ùå <b>–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–æ.</b>")
    await callback.answer(msg)

@dp.callback_query(F.data.startswith("whisper_open"))
async def cb_whisper_open(callback: CallbackQuery):
    import time
    try:
        _, token, rid, sid = callback.data.split(":")
        rid, sid = int(rid), int(sid)
    except:
        await callback.answer("–û—à–∏–±–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞.", show_alert=True)
        return

    if callback.from_user.id != rid:
        await callback.answer("–≠—Ç–æ –Ω–µ –¥–ª—è —Ç–µ–±—è!", show_alert=True)
        return

    async with whispers_lock:
        data = whispers.get(token)
        if not data:
            await callback.answer("–ü—Ä–æ—à–µ–ø—Ç–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –∏–ª–∏ —É–∂–µ –æ—Ç–∫—Ä—ã—Ç–æ.", show_alert=True)
            return
        if data["to"] != rid:
            await callback.answer("–≠—Ç–æ –Ω–µ –¥–ª—è —Ç–µ–±—è!", show_alert=True)
            return
        text = data["text"]
        del whispers[token]

    await callback.answer(text, show_alert=True)
    try:
        await callback.message.edit_text(callback.message.text + "\n\nüîì –ü—Ä–æ—à–µ–ø—Ç–∞–Ω–Ω–æ–µ –æ—Ç–∫—Ä—ã—Ç–æ.")
    except:
        pass

@dp.callback_query(F.data.startswith("marriage_accept"))
async def cb_mar_accept(callback: CallbackQuery):
    _, pid, rid, gid = callback.data.split(":")
    pid, rid, gid = int(pid), int(rid), int(gid)
    if callback.from_user.id != rid:
        await callback.answer("–≠—Ç–æ –Ω–µ –¥–ª—è —Ç–µ–±—è!", show_alert=True)
        return
    msg = respond_marriage(gid, pid, rid, accept=True)
    pname = get_username_by_id(pid, gid)
    rname = get_username(callback.from_user)
    await callback.message.edit_text(f"üéâ <b>{rname}</b> –∏ <b>{pname}</b> —Ç–µ–ø–µ—Ä—å –≤ –±—Ä–∞–∫–µ!")
    await callback.answer(msg)

@dp.callback_query(F.data.startswith("marriage_decline"))
async def cb_mar_decline(callback: CallbackQuery):
    _, pid, rid, gid = callback.data.split(":")
    pid, rid, gid = int(pid), int(rid), int(gid)
    if callback.from_user.id != rid:
        await callback.answer("–≠—Ç–æ –Ω–µ –¥–ª—è —Ç–µ–±—è!", show_alert=True)
        return
    msg = respond_marriage(gid, pid, rid, accept=False)
    await callback.message.edit_text("‚ùå <b>–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–æ.</b>")
    await callback.answer(msg)

def get_user_profile(user_id: int, group_id: int):
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute('''
        SELECT username, total, daily, weekly, monthly, vip, diamonds, tickets, vip_until
        FROM users
        WHERE user_id=? AND group_id=?
    ''', (user_id, group_id))
    row = c.fetchone()
    conn.close()

    if not row:
        return "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ —Ç–µ–±–µ.", False

    username, total, daily, weekly, monthly, vip, diamonds, tickets, vip_until = row

    # üß© –¥–æ–±–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å —Ä–µ–ø—É—Ç–∞—Ü–∏–∏
    conn_r = sqlite3.connect(DB)
    cr = conn_r.cursor()
    cr.execute("SELECT COALESCE(rep, 0) FROM users WHERE user_id=? AND group_id=?", (user_id, group_id))
    result = cr.fetchone()
    rep_val = result[0] if result else 0
    conn_r.close()

    # üèÜ –º–µ—Å—Ç–æ –≤ —Ä–µ–π—Ç–∏–Ω–≥–µ
    conn2 = sqlite3.connect(DB)
    c2 = conn2.cursor()
    c2.execute('SELECT COUNT(*)+1 FROM users WHERE group_id=? AND total > ?', (group_id, total))
    place = c2.fetchone()[0]
    conn2.close()

    rank = get_rank(total)
    vip_act = is_vip_active(user_id, group_id)
    vip_str = "‚ú® –î–∞" if vip_act else "–ù–µ—Ç"
    vip_time = ""
    if vip_act and vip_until:
        try:
            until = datetime.strptime(vip_until, "%Y-%m-%d %H:%M:%S")
            vip_time = f"\nüïí VIP –¥–æ: <b>{until.strftime('%d.%m.%Y %H:%M:%S')}</b>"
        except Exception:
            vip_time = ""

    # üí¨ –∏—Ç–æ–≥–æ–≤—ã–π —Ç–µ–∫—Å—Ç
    text = (
        f"üë§ <b>–ü—Ä–æ—Ñ–∏–ª—å {username}</b>\n"
        f"üèÜ –í—Å–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏–π: <b>{total}</b>\n"
        f"üìÖ –ó–∞ –¥–µ–Ω—å: <b>{daily}</b>\n"
        f"üóì –ó–∞ –Ω–µ–¥–µ–ª—é: <b>{weekly}</b>\n"
        f"üóì –ó–∞ –º–µ—Å—è—Ü: <b>{monthly}</b>\n"
        f"üéñ –†–∞–Ω–≥: <b>{rank}</b>\n"
        f"ü•á –ú–µ—Å—Ç–æ: <b>{place}</b>\n"
        f"üíé –ê–ª–º–∞–∑—ã: <b>{diamonds}</b>\n"
        f"üé´ –ë–∏–ª–µ—Ç—ã: <b>{tickets}</b>\n"
        f"üìù –†–µ–ø—É—Ç–∞—Ü–∏—è: <b>{rep_val}</b>\n"
        f"üåü VIP: <b>{vip_str}</b>{vip_time}"
    )

    return text, vip_act

def get_rank(messages: int) -> str:
    if messages >= 350_000:
        return "üü™ –û–±—Å–∏–¥–∏–∞–Ω"
    elif messages >= 200_000:
        return "‚¨úÔ∏è –ü–ª–∞—Ç–∏–Ω–∞"
    elif messages >= 100_000:
        return "üíö –ò–∑—É–º—Ä—É–¥"
    elif messages >= 50_000:
        return "üî∑ –ê–ª–º–∞–∑"
    elif messages >= 25_000:
        return "üü° –ó–æ–ª–æ—Ç–æ"
    elif messages >= 10_000:
        return "‚ö™Ô∏è –°–µ—Ä–µ–±—Ä–æ"
    return "–ù–µ—Ç —Ä–∞–Ω–≥–∞"

def find_user_id_by_nick(group_id: int, nick: str):
    conn = sqlite3.connect(DB)
    c = conn.cursor()

    # –£–±–∏—Ä–∞–µ–º @, –ø—Ä–æ–±–µ–ª—ã, –ø—Ä–∏–≤–æ–¥–∏–º –∫ –Ω–∏–∂–Ω–µ–º—É —Ä–µ–≥–∏—Å—Ç—Ä—É
    nick = nick.strip().lstrip("@").lower()

    # –ü—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ –ø–æ username (—á–∞—Å—Ç–∏—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ)
    c.execute('SELECT user_id FROM users WHERE group_id=? AND LOWER(username) LIKE ?', (group_id, f"%{nick}%"))
    row = c.fetchone()

    # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ ‚Äî –ø—Ä–æ–±—É–µ–º –ø–æ –∏–º–µ–Ω–∏ (–Ω–∞ —Å–ª—É—á–∞–π, –µ—Å–ª–∏ username –ø—É—Å—Ç)
    if not row:
        c.execute('SELECT user_id FROM users WHERE group_id=? AND LOWER(username) LIKE ?', (group_id, f"%{nick}%"))
        row = c.fetchone()

    conn.close()
    return row[0] if row else None


# –ó–∞–ø—É—Å–∫
async def main():
    init_db()
    print("Bot started")
    await dp.start_polling(bot, skip_updates=True)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        print("Bot stopped")
